# 운영체제론 정리1[시스템 소프트웨어 ~ 프로세스 스케쥴링]
## 제어 프로그램(Control Program)
다음과 같은 작업들을 진행을 하는 프로그램으로 인지할 수 있다.
> - 시스템 전체의 작동 상태 감시
> - 작업의 순서 지정(프로세스 스케쥴링)
> - 작업에 사용되는 데이터 관리
> - 인터럽트 처리 역할

제어 프로그램의 종류로서는 아래 3가지로 나뉜다. 시험에 가끔 나오니 읽어두길 바란다.
> - 감시(Supervisor) 프로그램 : 각종 프로그램의 실행과 시스템 전체의 상태를 감시와 감독하는 프로그램.
> - 작업 제어(Job Control) 프로그램 : 어떤 업무를 처리하고 타 작업으로 이행을 자동으로 수행할 준비와 그 처리에 대한 완료를 담당하는 프로그램.
> - 자료 관리(Data Management) 프로그램 : 주기억장치와 보조기억장치 사이의 데이터 전송과 보조기억장치의 자료 갱신 및 유지 보수 기능을 수행하는 프로그램.

## 처리 프로그램(Process Program)
제어 프로그램의 지시를 받아 사용자가 요구한 문제를 해결하기 위한 프로그램.
> - 언어 변역(Language Translate) 프로그램 : 원시 프로그램을 기계어 형태의 목적 프로그램으로 번역하는 프로그램
> - 서비스(Service) 프로그램 : 컴퓨터를 효율적으로 사용할 수 있는 사용 빈도가 높은 프로그램.
> - 문제(Problem) 프로그램 : 특정 업무 및 해결을 위해 사용자가 작성한 프로그램.

## 운영체제(Operation System)의 개요
> 운영체제는 컴퓨터 시스템의 자원들을 효율적으로 관리하며, 사용자가 컴퓨터를 편하고 효과적으로 사용할 수 있도록 환경을 제공하는 여러 프로그램의 모임으로 칭한다.
- 운영체제의 목적은 처리 능력(Throughput), 신뢰도(Reliability), 사용 가능도(Availability)를 향상하고, 반환 시간(Turn Around Time)을 감축시키는데 있다.
> 사용 가능도(Availability) : 컴퓨터 시스템 내의 한정된 각종 자원들을 여러 사용자가 요구할 때 어느 정도 신속하고 충분히 지원해 줄 수 있는지에 대한 정도를 나타낸 개념.

운영체제의 기능은 아래와 같이 볼 수 있다.
> - 프로세스 관리를 우선적으로 한다.
>> 1. 사용자 프로세스와 시스템 프로세스의 생성과 제거.
>> 2. 프로세스의 중지와 재수행.
>> 3. **프로세스 스케쥴링**
> - 프로세서, 기억장치, 입-출력 장치, 파일 및 정보 등의 자원 관리.
> - 자원의 효과적인 경영 스케쥴링 기능 제공. 
> - 사용자와 시스템 간 인터페이스 제공.
> - 시스템의 각종 하드웨어와 네트워크 관리와 제어.
> - 시스템의 오류 검사 및 복구, 데이터 관리, 데이터 및 자원 공유를 한다.
> - 자원 보호 기능, 가상 계산기 기능을 제공한다.
> - 병렬 수행을 위한 편의성 제공.

* * * 

## 운영체제 운용 기법과 발달 과정
> - 운영체제론에서 가장 기초가 되는 개념이니 이를 꼭 읽고 넘어가야 한다.
> - 발달 순서대로 작성을 하였다.

> ### 일괄 처리 시스템(Betch Processing System)
> - 초기 컴퓨터 시스템에서 사용된 형태로서 **일정량, 일정 기간**동안 데이터를 모아서 **한 방에 처리**하는 방식.
> - 컴퓨터 시스템을 효율적으로 사용할 수 있다.
> - 사용자 측면에서는 자원 반납이 늦어져도 모든 자원들이 독점하여 **CPU의 유휴 시간**이 줄어든다.

> ### 다중 프로그래밍(Multi Programming)
> - 하나의 CPU와 주기억장치를 이용해서 여러 프로그램을 동시에 관리하는 방식.
> - 하나의 주기억장치에서 2개 이상의 프로그램을 기억시키고 하나의 CPU와 대화하면서 동시에 처리한다.
> - CPU가 하나 밖에 없어서 타 프로그램에 대해서 **CPU 유휴 시간**이 존재할 수 밖에 없는 단점도 있다.

> ### 시분할 시스템(Time Sharing System)
> - 여러 사용자가 사용하는 시스템에서 컴퓨터가 사용자들의 프로그램을 번갈아 처리해 각 사용자들에게 독립된 컴퓨터를 사용하는 느낌을 줘서 Round Robin 방식을 제공함.
> - 여러 사용자가 각 단일 장치를 통해 운영체제와 대화를 하면서 각자 프로그램을 실행해서 **독립된 기능**을 제공하게 되면서 **모든 작업이 동시에 진행되는 것**처럼 대화식 처리가 가능하다.
> - 하나의 CPU는 같은 시점에서 **여러 개 작업을 동시 수행을 하지 못하여** CPU의 전체 사용 시간을 Time Slice(Quantum)으로 나뉘어서 그 시간동안 번갈아 가면서 CPU를 할당하면서 작업을 처리한다. 

> ### 다중 처리 시스템(Multi-Processing System)
> - 여러 개의 CPU와 하나의 주기억 장치를 이용해서 여러 개의 프로그램을 동시에 처리하는 방식.
> - 하나의 CPU가 빠갈나도 다른 CPU를 이용하면 되니깐 시스템의 신뢰성과 안전성을 높여준다.

> ### 실시간 처리 시스템(Real Time Processing System)
> - 데이터 발생 즉시, 데이터 요구가 있는 즉시 처리해 결과를 산출하는 방식.
> - 응용 과학, 천문학 과학 뿐만 아니라 실생활에서 예약 시스템 등에서 주로 이용을 한다.

> ### 다중 모드 처리(Multi Mode Processing)
> - 일괄 처리 시스템, 시분할 시스템, 다중 처리 시스템, 실시간 처리 등을 한 시스템 내부에 짬뽕한 개념.

> ### 분산 처리 시스템(Distributed Processing System)
> - 여러 개의 컴퓨터를 통신 회선으로 연결해 하나의 작업을 처리하는 방식.
> - 각 단말 장치나 컴퓨터 시스템은 고유의 CPU와 메모리를 지닌다.

## Macro(매크로)
- 매크로는 엑셀에서 제공하는 기능과 플래시 게임을 해 본 경험이 있다면 이미 잘 아는 개념이다.
- Macro Processor : 원시 프로그램에 존재하는 호출 부분에 Macro 프로그램을 삽입해 확장된 원시 프로그램을 생성하는 시스템 소프트웨어.
- 매크로 프로세서 처리 과정
> 매크로 정의 인식 -> 매크로 정의 저장 -> 매크로 호출 인식 -> 매크로 확장과 인수 치환.

* * * 

## 링거
- 언어 번역 프로그램이 생성한 목적 프로그램들과 라이브러리, 또 다른 프로그램 등을 연결하여 실행 가능한 로드 모듈을 만드는 시스템 소프트웨어다.
- 연결 가능만 수행하는 로더의 형태로 링거에 의해 수행되는 작업을 **링킹**이라고 한다.

## 로더(Loader)
컴퓨터 내부로 정보를 들여오거나 로드 모듈을 디스크 등의 보조기억장치로부터 주기억장치에 적재하는 시스템 소프트웨어로 칭한다.
> - Allocation(할당) : 실행 프로그램을 실행하기 위해 기억 장치 내에 옮겨 놓을 공간을 확보하는 기능.
> - Linking(연결) : 부프로그램 호출 시 그 부프로그램이 할당된 기억장소의 시작 주소를 호출한 부분에 등록하여 연결하는 기능.
> - Relocation(재배치) : 디스크 등의 보조기억장치에 저장된 프로그램이 사용하는 각 주소들을 할당된 기억장소의 실제 주소로 배치시키는 기능.
> - Loading(적재) : 실행 프로그램을 할당된 기억공간에 실제로 옮기는 기능.
### 로더의 종류
> ### Compile And Go 로더
>> 언어 번역 프로그램이 로더의 기능까지 수행하는 방식.(할당, 재배치, 적재 작업을 모두 언어 번역 프로그램이 담당.)
> ### Absolute Loader(절대 로더)
>> - 목적 프로그램을 **기억 장소에 적재시키는 기능만 수행**하는 로더. 로더 중 간단한 프로그램으로 구성이 되어 있음.
>> - 프로그램은 **할당과 연결**을 담당해야 하고, 언어 번역 프로그램은 **재배치**를 담당하게 된다.
>> - 절대 로더는 직접 연결 로더, 동적 적재 로더 2가지로 나뉘게 된다.
>> 1. 직접 연결 로더 : 일반적인 기능의 로더로서 로더의 기능 4가지를 모두 수행한다.
>> 2. 동적 적재 로더 : 프로그램을 한꺼번에 적재하는 것이 아닌 실행 시 일부분만 적재를 하는 로더 개념으로 인지할 수 있다.

* * * 

## 프로세스(Process) 
> 프로세스는 일반적인 프로세서(CPU)에 의해 처리되는 사용자 프로그램이나 시스템 프로그램을 의미하고, 각종 필요 자원들을 요구한다.
- 프로세스의 정의는 또한 아래처럼 언급할 수도 있다.
> 1. 실행 중인 프로그램, PCB를 가진 프로그램, 실기억 장치에 저장된 프로그램.
> 2. 프로세서가 할당되는 실체, 프로시저가 활동 중인 것.
> 3. **비동기적 행위**를 일으키는 주체, 지정된 결과를 얻기 위한 일련의 계통적 동작.
> 4. 목적 또는 결과에 따라 발생되는 사건들의 과정.
> 5. 프로세서가 할당하는 개체로서 **디스패치**가 가능한 단위.

## PCB(Processor Control Block)
> 운영체제가 프로세스에 대한 중요한 정보를 저장해 놓은 곳으로 각 프로세스가 생성될 때마다 고유의 PCB가 생성되고 프로세스가 완료되면 PCB가 제거된다.
- PCB에는 아래와 같은 정보를 저장한다.
> - 프로세스 현재 상태, 포인터
> > - 부모 / 자식 프로세스에 대한 포인터.
> > *그렇다고 부모와 자식 프로세스가 PCB를 공유하는 것까지는 아니다.*
> > - 프로세스가 위치한 메모리에 대한 포인터.
> > - 할당된 자원에 대한 포인터
> - 프로세스 고유 식별자
> - 스케쥴링 및 프로세스 우선 순위
> - CPU 레지스터 정보(AC, IR, PC etc.)
> - 주기억장치 관리 정보, IO 상태 정보, 계정 정보 etc.

## 프로세스의 주요 상태
![processor_state_pict](/Computer_Science_Documents/3_OperationSystem/img/processor_state_pict.png "processor_state_pict")
### 상태에 대한 용어
- Ready(준비) : 프로세스가 프로세서(CPU)에게 자원 할당을 받기 위해 기다리는 상태.
- Run(실행) : 준비 상태 Queue에 있는 프로세스가 프로세서를 할당 받아 실행되는 상태로 수행이 완료 전에 할당 시간이 종료(Time Run Out). 실행 중인 프로세스에 IO 처리가 필요하면 실행 중인 프로세스는 대기 상태로 전환이 된다. 
- Wait(대기) : IO 요구가 발생되어 현재 실행 중인 프로세스가 중단되고 IO 처리가 완료 될 때까지 대기하는 상태.
### 상태 전이에 대한 용어
- Dispatch(디스패치) : 준비 상태에서 대기하고 있는 프로세스 중 하나가 프로세서에게 자원을 할당 받아 실행 상태로 전이하는 과정.
- Wake-Up : IO 작업이 완료되어 프로세스가 대가 상태에서 준비 상태로 전환하는 과정.

## 스레드(Thread)
> 하나의 프로세스 내에서 **병행성**을 증대시키기 위한 메커니즘으로 시스템의 여러 자원을 할당받아 실행하는 프로그램 단위.
- 독립적인 스케쥴링의 최소 단위로서 동일한 환경에서 서로 독립적인 다중 수행이 가능하다.
- 스레드는 독립적인 스케쥴링 최소 단위로 프로세스 역할을 담당함.
- 하나의 프로세스에는 한 개 혹은 여러 개 이상의 스레드가 존재할 수 있다. 이를 각각 단일 스레드, 다중 스레드로 칭한다.
- 스레드는 프로세스의 일부 특성을 지니고 있어서 **경량 프로세스**라고도 한다.
- 유의 사항으로 Thread는 **외부에는 절대로 존재할 수 없다.** 오로지 어느 Process 내부에서만 작동을 한다.
> ### 스레드의 분류
> - 사용자 수준의 Thread : 사용자가 만든 라이브러리를 이용해 Thread를 운용을 하지만 구현이 장난 아니게 어렵다.
> - 커널 수준의 Thread : 운영체제의 커널에 의해 Thread를 운용을 하지만 구현은 쉬운데 속도가 느리다.
> ### Thread 장점
> - 하나의 프로세스를 여러 개 Thread로 생성해 병행성을 증진시킨다.
> - 하드웨어, 운영체제의 성능과 응용 프로그램의 처리율을 향상시킨다.
> - 응용 프로그램의 응답 시간을 단축시킨다.
> - **실행 환경을 공유**시켜 기억 장소 및 자원 낭비가 줄어든다.
> - 공통적으로 접근 가능한 기억장치를 통해 효율적으로 통신한다.

* * *

## 스케쥴링과 문맥 교환
- 스케쥴링 : 프로세스가 생성되어 실행될 때 필요한 시스템의 여러 자원을 해당 프로세스에게 할당하는 작업.
- 스케쥴링의 목적으로는 공정성, 처리율 증가, CPU 이용률 증가, 우선 순위 제도, 오버헤드 최소화, 응답 시간 최소화, 반환 시간 최소화, 대기 시간 최소화, 균형 있는 자원 사용 etc.
- 문맥 교환(Context Switching) : 운영체제의 Overhead를 유발하는 한 요소. 하나의 프로세스가 타 프로세스로 CPU가 할당되는 과정에서 발생되는 것. 새로운 프로세스에게 CPU를 할당하기 위해 현재 CPU가 할당된 프로세스의 상태 정보를 저장하고 새로운 프로세스의 상태 정보를 설정하고 CPU를 할당하여 실행되도록 하는 작업이다.

## 프로세서 스케쥴링의 종류
> 여기서부터는 운영체제론에서 한 두 문제는 꼭 나오니 읽고 넘어가야 한다.
> ### 비선정 스케쥴링(Non-Preemptive Scheduling)
> - 이미 할당된 CPU를 강제로 뺏지 못하게 하는 기법.
> - 타 프로세스가 CPU에게 할당 받기 위해서는 기다려야 한다. 그 프로세스가 몇 년이 걸릴지 언정.
> - 모든 프로세스에 대한 **공정 처리** 보장.
> - 일괄 처리(Fetch Processing)에서 적합하다.
> - 응답 시간 예측이 용이하다.
> - FIFO(FCFS), SJF, HRN 등이 있다.
> ### 선점 스케쥴링(Preemptive Scheduling)
> - 하나의 프로세스가 CPU를 할당받아 실행하고 있을 때 우선순위가 높은 다른 프로세스가 CPU를 강제로 빼앗아 사용할 수 있는 스케쥴링 기법.
> - 우선순위가 **높은 프로세스**에게 적합함.
> - 빠른 응답시간을 요구하는 **대화식 시스템**에 적합한 편.
> - 비선점 스케쥴링과 반대로 많은 오버헤드를 초래할 수 있다.
> SRT, 선점 우선순위, Round Robin, 다단계 큐, 다단계 피드백 큐 etc.

## 비선점 스케쥴링의 종류
> 모든 실행 시간은 다음과 같이 정의가 되어 있다고 가정을 하자.
> 
> |프로세스|도착 시간|실행 시간|
> |:-------:|:-------:|:-------:|
> |p1|0|5|
> |p2|1|7|
> |p3|2|3|
> |p4|3|1|
>
> ### FIFO(FCFS) 기법
> ![processor_fifo](/Computer_Science_Documents/3_OperationSystem/img/processor_fifo.png "processor_fifo")
> - 위를 기반으로 평균 반환 시간은 10.5가 된다.
> - 준비 상태 큐에 도착한 순서에 따라서 차례로 CPU를 할당하는 방법
> - 먼저 도착한 것이 먼저 처리되지만, 우선 순위에 위반이 되는 단점도 존재하기는 함.

> ### SJF(Shortest Job 1st) 기법
> ![processor_sjf](/Computer_Science_Documents/3_OperationSystem/img/processor_sjf.png "processor_sjf")
> - 위를 기반으로 평균 반환 시간은 7.5가 된다.
> - 실행 시간이 들어온 순서대로 가장 짧은 프로세스가 먼저 CPU를 할당하는 기법.
> - 가장 적은 평균 대기 시간을 제공하는 최적의 알고리즘.

> ### HRN(Hightest Response-Ratio Next)
> 위를 기반으로 대기 시간과 서비스 시간으로 다시 나타내면 아래와 같이 표로 작성할 수 있다.(대기 시간은 SJF를 기반으로 잡아 보겠다.)
>
> |프로세스|대기 시간|서비스(실행) 시간|
> |:-------:|:-------:|:-------:|
> |p1|0|5|
> |p2|9|7|
> |p3|5|3|
> |p4|2|1|
> 
> - 이처럼 계산을 하게 된다면 각 프로세스의 우선 순위 지수는 p1의 는 1, p2는 약 2.3, p3은 2.6, p4는 3으로 각각 p4->p3->p2->p1 순으로 진행이 된다.
> - 실행 시간이 긴 프로세스에 불리한 SJF 기법을 보완하기 위해 대기 시간과 서비스 시간을 이용하는 방법.
> - 우선순위 계산 공식은 **(대기시간 + 서비스 시간) / 서비스 시간**으로 정의 된다.
> - 우선순위는 높은 수치부터 낮은 수치 순으로 적용이 된다.

## 선점 스케쥴링의 종류
> ### SRT(Shortest Remainin' Time)
> 비선점 기법인 SJF 알고리즘을 선점 형태로 변환하는 방법으로 현재 프로세스의 남은 시간과 준비상태 큐에 새로 도착한 프로세스의 실행 시간을 비교하여 가장 짧은 실행 시간을 구하는 프로세스에게 CPU를 할당하는 기법.
> - SRT 알고리즘은 워낙 복잡해서 일단 넘어가도록 하고, 정처기 시험 끝나는데로 재작성을 하겠다. 정처기 기준에서는 SRT와 SJF의 차이만 알아두는 시점에서 끝내면 된다.
> ### RR(Round Robin)
> ![processor_rr](/Computer_Science_Documents/3_OperationSystem/img/processor_rr.png "processor_rr")
> 각 Time Slice를 2로 두고 계산을 하면 위처럼 작성이 된다. 평균 반환 시간은 10.5이다.
> 
> **의외로 Round Robin도 선점 스케쥴링에 속하니 기억을 해두고 넘어가야 한다.**
> - FIFO 기법과 같이 준비 상태 큐에 먼저 들어온 프로세스가 먼저 CPU를 할당하고 각 프로세스를 할당 받지만 각 프로세스는 할당 된 시간(Time Slice) 동안만 실행하고 실행 할 것이 없다면 넘겨주는 방식으로 진행을 하게 된다.
> - Time Slice가 크면 FIFO와 다를 바가 없어지고, 그렇다고 너무 작으면 **문맥 교환으로 인한 오버헤딩**이 발생하게 된다.
> ### 다단계 큐
> 프로세스를 특정 그룹으로 분류할 수 있을 경우 그룹에 따라 각 다른 준비상태 큐를 이용하는 기법.
> ### 다단계 피드백 큐
> 특정 그룹의 준비 상태 큐에 들어간 프로세스가 다른 준비 상태 큐로 이동할 수 없도록 하기 위해 **적응 기법**을 이용해서 준비 상태 큐 사이를 이동할 수 있도록 개선한 기법.