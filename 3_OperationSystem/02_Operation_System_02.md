# 운영체제론 정리2[임계구역 ~ Thrashing]
## 임계 구역(Critical Section)
> 쉽게 생각해 프로세스들의 화장실로 생각하면 된다.
- 다중 프로그래밍 운영체제에서 여러 개의 프로세스가 공유하는 데이터 및 자원에 대하여 어느 한 시점에서는 하나의 프로세스만 자원 또는 데이터를 사용할 수 있도록 지정된 공유 자원(혹은 Area)을 의미.
- 임계 구역에서는 **하나의 프로세스** 만 접근할 수 있음.
- 임계 구역은 특정 프로세스가 독점할 수 없다.
- 임계 구역의 자원이나 데이터는 여러 프로세스가 이용해야 되어 신속한 작업을 이뤄져야 한다.
- 프로세스 임계 구역에 대한 진입을 요청하면 일정 시간 이내 진입을 허락해야 한다.
- 현재 임계 구역에 실행되는 프로세스가 없다면 잔류 영역에서 임계 구역 사용을 기다리고 있는 프로세스의 사용을 허락해야 하며, 그 이외에 있는 프로세스는 임계 구역에 진입할 수 없다.

## 상호 배제(Mutual Exclusion)
- 특정 프로세스가 공유 자원을 사용하는 경우에 다른 프로세스가 해당 공유 자원을 사용하지 못 하도록 제어하는 기법.
- 여러 프로세스가 동시에 공유 자원을 사용하러 갈 때 각 프로세스가 번갈아가며 공유 자원을 사용하는 것으로 임계 구역을 유지하는 기법.
- 상호 배제 기법을 사용함으로서 임계 구역 내에서는 인터럽트, 교착 상태, 무한 반복이 발생하면 안 된다.
- 상호 배제 구현 기법
> - 소프트웨어적 구현 방법 : Dekker 알고리즘, Peterson 알고리즘
> - 하드웨어적 구현 방법 : Test & Set 기법

### 세마포어(Semaphore)
> - 각 프로세스에 제어 신호를 전달하여 순서대로 작업을 수행하도록 하는 기법.
> - 다익스트라가 제안하였으며 P, V 2개의 연산에 의해 동기화를 유지시키고 상호 배제의 원리를 보장한다.
> - 여러 개의 프로세스가 동시에 값 수정을 하지 못한다.
> - S는 P, V 연산으로만 접근 가능한 세마포어 변수로 공유 자원의 수를 나타내며 [0, 1] 아니면 [0, n(n>0인 정수)]의 범위를 가진다.
> - P 연산 : 자원을 사용하는 프로세스들의 진입 여부를 자원의 개수(S)를 통해 결정하는 것. 자원의 수를 감소 시켜서(S = S-1), 자원이 점유되었음을 Wait 상태를 통해 알림.
> - V 연산 : 대기 중인 프로세스를 깨우는 신호(Wake Up)로서 자원의 개수를 증가 시켜서(S = S+1) 자원 반납이 완료 되었음을 알린다.

## 모니터(Monitor)
> - 동기화를 구현하기 위한 특수 프로그램 기법으로 특정 공유 자원을 프로세스에게 할당하는데 필요한 데이터와 이 데이터를 처리하는 프로시저로 구성된다.
> - 자료 추상화와 **정보 은폐 개념**을 기초로 공유 자원을 할당하기 위한 병행성 구조로 이뤄진다.
> - 모니터 내의 공유 자원을 사용하기 위해 프로세스는 반드시 모니터 진입부를 호출해야 한다.
> - 외부 프로시저는 **직접 엑세스 할 수 없다.** 모니터의 경계에서 상호 배제가 실행된다.
> - **한 순간에 하나의 프로세스만** 진입하여 자원을 사용할 수 있다.

* * *

## 교착 상태 해결하기
교착 상태를 해결하는 방안에는 예방, 회피, 발견, 회복 4가지로 나뉜다. 각각 알아보도록 하겠다.
> ### 예방(Prevention) 기법
> - 교착 상태가 발생하지 않도록 사전에 시스템을 제어하는 방법. 교착 상태의 4가지 조건 중에서 어느 하나를 제거하고 추측을 하는 방안으로 수행되어 자원 낭비가 심할 수 밖에 없다.
> - 상호 배제 부정, 점유 및 대기 부정, 비선점 부정, 환형 대기 부정 4가지 중 하나를 빼고 봐야 한다.
> ### 회피(Avoidance) 기법
> - 교착 상태가 발생할 가능성을 배제하지 않고 교착 상태가 발생하면 적당히 피하는 방법. **Banker(은행원) 알고리즘**을 주로 쓴다.
> ### 발견(Detection) 기법
> - 시스템에 교착 상태가 발생했는지 점검하여 교착 상태에 있는 프로세스와 자원을 **발견**하는 것으로 자원 할당 그래프에서 이용한다.
> ### 회복(Recovery) 기법
> - 교착 상태를 일으킨 프로세스를 종료시키거나 교착 상태의 프로세스에 할당된 자원을 선점시켜 프로세스나 자원을 **회복**하는 것.

* * *

## 기억 장치 관리 전략
> ### 반입(Fetch) 전략
> - 보조기억장치에 보관 중인 프로그램이나 데이터를 언제 주기억장치로 적재할 것인지를 결정하는 전략.
> - 요구 반입, 예상 반입 2가지로 나뉜다.
> ### 배치(Placement) 전략
> - 새로 반입되는 프로그램이나 데이터를 주기억장치의 어디에 위치시킬 것인지를 결정하는 전략.
> First-Fit, Best-Fit, Worst-Fit 3가지로 나뉜다.
> 
> |영역|용량|
> |:-------:|:-------:|
> |영역1|10K|
> |영역2|15K|
> |영역3|20K|
> |영역4|14K|
>
> 13K 프로그램이 할당된다면 First-Fit에 적합한 영역은 영역2, Best-Fit에 적합한 영역은 영역4, Worst-Fit에 적합한 영역은 영역3이다.
>
> ### 교체(Replacement) 전략
> 주기억장치의 모든 영역이 이미 사용 중인 상태에서 가상 기억장치의 필요한 페이지를 주기억장치에서 배치할 때 이미 사용하고 있는 영역 중에서 어느 영역을 교체하여 사용할지에 대한 전략. FIFO, OPT, LRU, LFU, NUR, SCR 등이 있다.

## 단편화
> 분할된 주기억장치에 프로그램을 할당하고 반납하는 과정을 반복하면서 사용하지 않고 남는 기억 장치의 빈 공간 조각을 뜻한다.
> - 내부 단편화 : 분할된 영역이 할당될 프로그램의 크기보다 크기 때문에 할당된 후 이용하지 않은 공간. 이는 **페이징**에서 주로 발생한다.
> - 외부 단편화 : 분할된 영역이 할당될 프로그램의 크기보다 작기 때문에 할당을 할 수 없게 되어 이용되지 않고 빈 공간으로 남아 있게 되는 분할된 전체 영역. 이는 **세그먼테이션**에서 주로 발생한다.
>> - 주소 변환 : 논리적인 가상 주소를 물리적인 실기억주소로 변환하는 과정으로 주소 사상 혹은 매핑으로 칭한다.
> - 단편화를 해결하기 위해 인접한 공간을 하나의 공간으로 합치는 **통합 기법**이 있고, 단편화된 빈 공간을 결합시켜 하나의 큰 가용 공간을 만드는 **압축 기법** 2가지가 있다.

## 가상 기억 장치(Virtual Memory)
- 보조기억장치의 일부를 주기억장치 처럼 사용하는 기법.
- 주기억장치의 용량보다 큰 프로그램을 실행하기 위해 사용.
- 가상 기억장치에 저장된 프로그램 실행 시에 가상 기억장치의 주소를 주기억장치의 주소로 바꾸는 주소 변환 작업인 **주소 매핑**이 필요하다.
- 블록 단위로 나뉘어 사용해서 연속 할당 방식에서 발생할 수 있는 단편화를 해결할 수 있다.
- 기억 장치의 이용률과 다중 프로그래밍의 효율도 또한 알아서 성장한다.
- 운영체제의 설계가 복잡해지고 주소 변환을 위한 테이블을 사용해서 기억장소의 낭비 또한 염려해야 한다.


## 페이징 기법 & 세그먼테이션 기법
> ### 페이징 기법
> - 가상 기억 장치에 보관된 프로그램과 주기억장치의 영역을 **동일한 크기**로 나누고 이를 주기억장치에 있는 페이지 프레임에 적재시켜 실행하는 기법.
> - **내부 단편화**에 취약하다.
> - **페이지 맵 테이블**이 필요하다.

> ### 세그먼테이션 기법
> - 가상 기억 장치에 보관된 프로그램을 **부지기수한 크기의 논리적 단위**로 나누고 주기억장치에 적재시켜 실행하는 기법.
> - 프로그램을 배열이나 함수 등의 논리적 단위(세그먼트)로 나누는데 이는 고유 이름과 크기를 가진다.
> - **외부 단편화**에 취약하다.
> - **세그먼트 맵 테이블**이 필요하다.

## 페이지 교체 알고리즘
페이지 부재가 발생할 때 가상 기억장치의 필요한 페이지를 주기억장치에 적재해야 하는데 모든 프레임이 사용 중일 때 쓰레싱이 발생하지 않도로 어느 페이지를 교체하는지에 대해 알아보는 기법이다.
> - OTP : 앞으로 가장 오랫동안 사용하지 않을 페이지 교체 기법이지만, 이는 실현 가능성이 희박함.
> - FIFO : 가장 먼저 들어와서 가장 오래 있었던 페이지를 교체하는 기법.
> - LRU : 최근에 **가장 오랫동안 사용하지 않은 페이지**를 교체하는 기법. 계수기나 스택을 두어서 조사를 한다.
> - LFU : **사용 빈도가 가장 적은 페이지**를 교체하는 기법.
> - NUR : 최근에 사용하지 않은 페이지를 교체하지만 사용 여부를 참고하기 위해 **참조 비트, 변형 비트**를 붙어서 최근 사용 여부를 확인한다.
> - SCR : 오랫동안 주기억장치에 있던 페이지 중에서 자주 사용되는 페이지 교체를 방지한다. FIFO의 단점을 보완한 기법. 
> ## 페이지 크기에 따른 결과
> ### 페이지의 크기가 작으면...
> - 페이지 단편화가 감소가 된다.
> - 프로그램에 필요한 내용만 주기억장치에 적재하고 Locality(국부성, 지역성)에 더 일치할 수 있어서 기억장치의 효율을 증대한다.
> - 페이지 맵 테이블의 크기가 커진다. 이럴 수록 매핑 속도가 늦어진다.
> - 디스크 접근 횟수가 많아져서 IO 시간만 날릴 수도 있다.
> - 그래도 워킹 셋은 효율적으로 작성할 수 있다.
> ### 페이지의 크기가 커지면...
> - 페이지 단편화가 증가하고 한 페이지를 주기억장치에 이동시키는 시간이 늘어난다.
> - 디스크 접근 횟수가 줄어들어 IO 효율성이 증가한다.
> - 페이지 맵 테이블 크기가 작아지면서 매핑 속도가 증가된다.
> - 그렇지만 잘 못 하면 불필요한 내용들도 포함되어 주기억장치에 적재될 수도 있다.

## 국부성(혹은 지역성)
- 실행 중인 프로세스가 주기억장치를 참조할 때 일부 페이지에 집중적으로 참조하는 성질이 있다는 이론으로 Denning에 의해 증명됨.
- 스래싱을 방지하기 위한 **워킹 셋 이론의 기반, 가상 기억장치 관리의 이론적인 근거**가 된다.
- 캐시 메모리 시스템의 이론적인 근거로도 볼 수 있다.
> ### 시간 구역성
> - 프로세스가 실행되면서 하나의 페이지를 **일정 시간**동안 집중적으로 액세스 하는 현상
> - Loop문, Stack, Sub Routine(부 프로그램), Counting 등등
> ### 공간 구역성
> - 프로세스 실행 시 **일정 위치**의 페이지를 집중적으로 액세스하는 현상 
> - 배열 순회, 순차적 코드 실행, 프로그래메들이 관련된 변수를 선언해 할당되는 기억장소, 같은 영역에 있는 변수를 참조할 때 이용.

## Working Set
- 프로세스가 일정 시간 동안 자주 참조하는 페이지의 집합.
- Denning이 제안한 프로그램의 움직임에 대한 모델로 Locality 특징을 사용한다.
- 자주 참조되는 워킹 셋을 주기억장치에 상주시킴으로 페이지 부재 및 교체 현상을 줄인다.

## 페이지 부재와 쓰레싱(Thrashin')
- 페이지 부재율(Page Fault Rate)에 따라서 주기억장치에 있는 페이지 프레임 수를 늘리거나 줄여 페이지 부재율을 적정 수준으로 유지하는 방식.
- Thrashing은 프로세스의 처리 시간보다 페이지 교체 시간이 더 많아지는 현상이다.
- 다중 프로그래밍 정도가 높아짐에 따라 CPU의 이용률은 어느 특정 시점까지 높아지지만 다중 프로그래밍의 정도가 더욱 커지면 스래싱이 일어나고 CPU의 이용률은 급격히 감속할 수도 있다.
> CPU 이용률을 높이고 Thrashin' 현상을 방지하는 방법
> - 다중 프로그래밍 정도를 **적정 수준**으로 유지.
> - 페이지 부재율을 조절한다.
> - Working Set를 유지한다.
> - 프로세스가 필요로 한 만큼의 프레임을 제공.
> - 부족한 자원을 증설시킨다.
> - 많이 쓰지 않는 프로세스를 종료시킨다.