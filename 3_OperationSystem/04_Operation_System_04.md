# 운영체제론 정리4[디스크 스케쥴링 ~ 보안]
## 프로세서 연결 방식
- 시분할 및 공유 버스 : 프로세서, 주변 장치, 기억 장치 등의 각종 장치들을 **버스**라는 단일 경로로 연결하는 방식. 한 시점에서는 하나의 전송만 가능하게 되어 있다.
- 크로스바 교환 행렬 : 시분할 및 공유 버스에서 버스의 수를 기억장치 수 만큼 증가시켜 연결한 방식. 단일 도로가 있다면 또 단일 도로를 합친 사거리 같은 원리로 생각하자. 장치의 연결이 꽤 복잡해진다.
- 하이퍼 큐브
> - 다수의 프로세서들을 연결하는 방식으로 비교적 경제적인 방식이다.
> - n차원 하이퍼 큐브롤 형성할 수 있다.
> - 하나의 프로세서에 연결되는 다른 프로세서의 수(연결점)이 n개일 경우에는 총 2^n개의 프로세서가 필요하다.
- 다중 포트 기억 장치 : 시분할 및 공유 버스 방식과 크로스바 교환 행렬 방식을 혼합한 방식으로 전송 시간이 비교적 느린 편이다.

## 다중 처리기의 운영체제 구조
> 주/종 처리기에 대한 개념은 인지하고 넘어가도록 하자. 정보처리기사 운영체제론 문제에서 한 문제는 종종 나오는 편이다.

> ### 주/종(Master/Slave) 처리기
> - 하나의 프로세서를 Master로 지정하고 나머지들은 Slave로 지정하는 **비대칭 구조**.
> - 주 프로세서(Master)가 고장나면 전체 시스템이 다운된다.
> - 주 프로세서(Master) : 입/출력, 연산을 담당. 운영체제를 가진 대가리다.
> - 종 프로세서(Slave) : 연산만 담당을 한다. 입/출력을 하고 싶다면 주 프로세서에게 보고를 하고 이용할 수 있다.

> ### 분리 실행 처리기
> - 주/종 처리기의 비대칭성을 보완하여 각 프로세서가 **독자적인 운영체제**를 가지고 있도록 구성한 구조.
> - 각 프로세서에서 발생하는 인터럽트는 해당 프로세서에서 해결을 한다.
> - 각 프로세서가 독자적인 OS를 가지고 있어서 한 프로세서가 고장나더라도 전체 시스템이 다운되지 않는다.

> ### 대칭적 처리기
> - 여러 프로세서들이 완전한 기능을 갖춘 하나의 운영체제를 공유하여 수행하는 구조.
> - 가장 복잡한 구조를 지녔으나 가장 강력한 시스템이다.
> - 여러 개 프로세서가 동시에 수행될 수 있고 시스템의 전반적인 정보를 통일적이고 일관성 있게 운영한다.
> - 프로세서 수를 늘려도 시스템 효율은 제자리이다.
> - 프로세서 간의 통신은 공유 메모리를 통해 이뤄진다.

## 프로세스의 결합도
다중 처리기는 각 프로세서 간 결합도에 따라서 약결합 시스템, 강결합 시스템으로 분류가 된다.
> ### 약결합 시스템(a.k.a. 분산 처리 시스템)
> - 각 프로세서마다 독립된 메모리를 가진 시스템이다.
> - 각 시스템마다 독자적인 운영체제를 가진다.
> - 각 시스템은 독립적으로 작동하고, 그들만의 상호적인 통신도 가능하다.
> - 프로세서 간 통신은 메시지 전달이나 원격 프로시저 호출을 통해 이뤄진다.
> - 각 시스템마다 독자적인 운영이 가능해서 CPU 간 결합력은 약한 편이다.

> ### 강결합 시스템(a.k.a. 다중 처리 시스템)
> - 동일 운영체제에서 여러 개 프로세서가 하나의 메모리를 공유해 사용하는 시스템이다.
> - 하나의 운영체제가 모든 프로세서와 시스템 하드웨어를 처리한다.
> - 프로세서 간 통신은 공유 메모리를 통해 이뤄진다.
> - 하나의 메모리를 사용해서 CPU 간 결합력이 강하다.
> - 공유 메모리를 차지하는 프로세서 간 경쟁을 최소화시켜야 한다.

## 분산처리 시스템 장/단점
분산처리 시스템의 궁극적인 목적은 자원 공유, 연산 속도 향상, 신뢰도 향상, 컴퓨터 통신이 가능하다.
> - 장점 : 통신 용이, 장치 공유, 데이터 공유, 중앙 컴퓨터 과부화 줄임, 컴퓨터 위치에 대해 몰라도 자원 사용 가능, 시스템 점진적 확장 등.
> - 단점 : 중앙 집중형 시스템에 비해 소프트웨어 개발이 어렵고 **특히 보안 문제**가 발생한다.

## 분산처리 시스템 투명성
- 투명성(Transparency) : 분산 처리 운영체제에서 구체적인 시스템 환경을 사용자가 알 수 없도록 하여 이에 대한 정보가 없어도 원하는 작업을 수행 할 수 있도록 하는 개념.
- 여러 유형의 투명성을 통해 자원의 위치나 정보가 변경되어도 사용자가 이를 인식하지 못하게 된다.

> ### 투명성의 종류
> - 위치 투명성 : 물리적인 위치를 몰라도 자원 접근에 무리가 없게 한다.
> - 이주 투명성 : 사용자나 응용 프로그램 동작에 영향이 없도록 하여 시스템 내 자원을 이동할 수 있게 한다.
> - 복제 투명성 : 자원의 복제를 자유롭게 하는 개념.
> - 병행 투명성 : 다중 사용자들이 자원을 병행 처리하고 공유할 수 있도록 함.
> - 접근 투명성 : 로그인 등과 같은 동작을 사용하여 지역이나 원격 자원에 접근할 수 있도록 한다.
> - 성능 투명성 : 성능을 증가시키기 위해 시스템을 재구성할 수 있도록 함.
> - 규모 투명성 : 시스템 구조나 응용 알고리즘 변동 없이 규모에 맞춰 확장하도록 한다.
> - 고장 투명성 : 하드웨어나 소프트웨어 구성 요소가 고장임에도 불구하고 작업을 완료할 수 있도록 한다.

## 위상에 따른 분산 처리 시스템 분류
- 완전 연결형 : 하나의 링크가 고장나더라도 다른 링크를 사용할 수 있고, 사이트의 수가 n개이면 링크 수는 n(n-1)/2로 계산된다. 물론 기본 비용은 많이 들지만 통신 비용은 적게 들고 신뢰성이 높은 편이다.
- 부분 연결형 : 시스템 내에 일부 사이트들만 직접 연결된 형태로 기본 비용은 당연히 완전 연결형보다 적게 들지만 통신 비용은 완전 연결형보다 많이 들이고 신뢰성이 낮다.
- 트리(계층)형 : 각 사이트들이 트리 형태로 연결된 구조. 기본 비용은 부분 연결형보다 더욱 줄어들고 통신 비용은 트리의 깊이에 비례하지만 부모 사이트가 마비되면 자식 사이트는 통신 자체가 불가능해진다.
- 스타(성, 별)형 : 모든 사이트가 하나의 중앙 사이트(Hub)에 직접 연결되어 있고 그 외 다른 사이트는 연결이 되어 있지 않은 구조로 기본 비용은 사이트의 수에 비례하고 통신 비용은 적게 들지만 중앙 사이트가 고장나면 모든 통신이 단절된다.
- 링(고리)형 : 시스템 내 각 사이트가 인접하는 다른 두 사이토와만 직접 연결된 구조로 정보는 단방향, 양방향으로 전달이 가능하고 기본 비용은 사이트 수에 비례하고 링을 순환하는 경우 통신 비용이 증가하게 된다.
- 다중 접근 버스 연결 : 시스템 내 모든 사이트들이 공유 버스에 연결된 구조로 기본 비용은 사이트 수에 비례하고 통신 비용은 일반적으로 저렴하다. 그러나 버스의 고장은 전체 시스템에 영향을 주고 사이트 추가, 삭제가 제일 용이한 편이다.

## UNIX 특징과 구성
- 시분할 시스템을 위해 설계된 대화식 운영체제로 C언어로 작성이 되어 이식성이 높으며 장치, 프로세스 간 호환성이 높은 편이다.
- 크기가 작고 이해하기 쉬우며 Multi-User, Multi-Tasking을 지원한다.
- 다양한 유틸리티 프로그램들이 존재하며, 정보와 유틸리티들을 공유하여 편리하게 작업을 수행할 수 있다.
- **트리 구조**의 파일 시스템으로 구성되고, 여러 개의 작업을 병행 처리할 수 있다.
> ### UNIX 구성
> **커널(Kernal)**
> - UNIX의 대가리를 역할하고, 하드웨어를 캡슐화하고 프로그램들과 하드웨어 간 인터페이스 역할을 담당한다.
> - 컴퓨터 부팅 시 주기억장치에 적재되어 상주하면서 실행이 되고, 프로세스 관리, 기억장치 관리, 파일 관리, 프로세스 간 통신, 데이터 전송 및 변환 등의 기능을 수행한다.
>
> **쉘(Shell)**
> - 사용자의 명령어를 인식시켜 프로그램을 호출하고 명령을 수행하는 명령어 해석기.
> - 시스템과 사용자 간의 인터페이스 담당.
> - 주기억장치에 상주하지 않고, 명령어가 포함된 파일 형태로 존재하며 보조기억장치에서 교체 처리가 가능하게 된다.
>
> **유틸리티(Utility)**
> - 일반 사용자가 작성한 응용 프로그램을 처리하는데 사용한다.

## UNIX 파일 시스템 
- UNIX 파일 시스템 디렉터리 구조는 아시다시피 **트리 구조**로 이뤄진다.
- 디렉토리나 주변장치를 파일과 동일하게 취급한다.
- 파일 생성, 삭제, 보호 기능 etc.
> ### UNIX 파일 시스템 구조
> - 부트 블록 : 부팅 시 필요한 코드를 저장하고 있는 블록.
> - 슈퍼 블록 : 전체 파일 시스템에 대한 정보를 저장하고 있는 블록으로 사용한 I-Node, 사용 가능한 디스크 블록의 개수를 인지하고 있음.
> - I-Node 블록 : 파일이나 디렉토리에 대한 모든 정보를 저장하는 브록으로 파일 소유자의 사용자 번호(UID), 그룹 번호(GID), 파일 크기, 파일 타입, 생성 시기, 최종 변경 시기, 최근 사용 시기, 파일 보호 권한, 파일 링크 수, 데이터 저장 블록 시작 주소 etc.
> - 데이터 블록 : 디렉토리 별 디렉토리 엔트리와 실제 파일에 대한 데이터가 저장된 블록.

## UNIX 주요 명령어
> git, raspberry-pi를 다루셨다면 쉽게 인지할 수 있다.
- fork : 새로운 프로세스 생성. 마치 GitHub에서 타 프로젝트롤 fork하면 자신의 Repository로 복사되어 저장되는 원리.
- exec : 새로운 프로세스 수행. execute에서 ute만 빼면 된다.
- & : 백그라운드 처리를 위해 명령의 끝에 입력.
- wait : fork 후 exec에 의해 실행되는 프로세스의 상위 프로세서가 하위 프로세스 종료 등의 이벤트를 기다리는 의미.
- exit : 프로세스 수행 종료.
- cat : 내용을 화면에 표시. 딱히 의미는 없지만 UNIX에 내용 표기를 원한다면 고양이를 연상하자.
- chmod : 파일의 사용 허가 지정. CHange MODify로 연상하자.
- chown : 소유자 변경. CHange OWNer로 연상하자.
- mount : 파일 시스템을 마운팅한다. 마운팅의 개념을 인지하면 쉽게 연상이 된다.
- mkfs : 파일 시스템을 생성한다. MaKe File System에서 대문자만 연상하자.
- chdir : 현재 사용할 디렉토리 위치 변경. Change DIRectory로 연상하자.
- fsch : 파일 시스템 검사 및 보수하여 무결성 검사를 진행. File System CHeck로 연상하자.
- rmdir : 디렉토리 삭제. ReMove DIRectory로 연상하자.
- ls : 현재 디렉토리 내 파일 목록 확인.
- getpid : 자신의 프로세스 아이디.
- getppid : 부모 프로세스 아이디.
- cp : 파일 복사. CoPy.
- mv : 파일 이동 및 이름 변경. MoVe.
- rm : 파일 삭제. ReMove.
- finger : 사용자 정보를 표시함. 사람을 지목할 때 손가락으로 지목을 한다는 걸 연상하자.